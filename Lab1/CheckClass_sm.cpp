//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : CheckClass.sm
//
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <map>
#include "CheckClass.h"
#include "CheckClass_sm.h"

using namespace statemap;

// Static class declarations.
CheckClassMap_StartState CheckClassMap::StartState("CheckClassMap::StartState", 0);
CheckClassMap_WordClass CheckClassMap::WordClass("CheckClassMap::WordClass", 1);
CheckClassMap_ClassName CheckClassMap::ClassName("CheckClassMap::ClassName", 2);
CheckClassMap_Colon CheckClassMap::Colon("CheckClassMap::Colon", 3);
CheckClassMap_Specificator CheckClassMap::Specificator("CheckClassMap::Specificator", 4);
CheckClassMap_ParentClass CheckClassMap::ParentClass("CheckClassMap::ParentClass", 5);
CheckClassMap_LeftBracket CheckClassMap::LeftBracket("CheckClassMap::LeftBracket", 6);
CheckClassMap_RightBracket CheckClassMap::RightBracket("CheckClassMap::RightBracket", 7);
CheckClassMap_OK CheckClassMap::OK("CheckClassMap::OK", 8);
CheckClassMap_ErrOfSymb CheckClassMap::ErrOfSymb("CheckClassMap::ErrOfSymb", 9);
CheckClassMap_EOP CheckClassMap::EOP("CheckClassMap::EOP", 10);

void CheckClassState::Class(CheckClassContext& context, const std::string& cls)
{
    Default(context);
}

void CheckClassState::DesiredSymb(CheckClassContext& context, const std::string& name)
{
    Default(context);
}

void CheckClassState::FindBr(CheckClassContext& context, const std::string& str)
{
    Default(context);
}

void CheckClassState::FindCol(CheckClassContext& context, const std::string& str)
{
    Default(context);
}

void CheckClassState::NameOfClass(CheckClassContext& context, const std::string& name)
{
    Default(context);
}

void CheckClassState::NextState(CheckClassContext& context, const std::string& name)
{
    Default(context);
}

void CheckClassState::NextWd(CheckClassContext& context, const std::string& spec)
{
    Default(context);
}

void CheckClassState::Start(CheckClassContext& context)
{
    Default(context);
}

void CheckClassState::Default(CheckClassContext& context)
{
    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

}

void CheckClassMap_StartState::Class(CheckClassContext& context, const std::string& cls)
{
    CheckClass& ctxt = context.getOwner();

    if ((cls.substr(0, 5) == "class") && ((cls[5] == ' ') || (cls[5] == '\t')))
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.put_fir(5);
            ctxt.put_sec(6);
            ctxt.word_stage();
            context.setState(CheckClassMap::WordClass);
        }
        catch (...)
        {
            context.setState(CheckClassMap::WordClass);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (cls == "end")

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.say_bye();
            context.setState(CheckClassMap::EOP);
        }
        catch (...)
        {
            context.setState(CheckClassMap::EOP);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         CheckClassMap_Default::Class(context, cls);
    }

}

void CheckClassMap_StartState::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(0);
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_WordClass::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(1);
        ctxt.ch_err();
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_WordClass::NameOfClass(CheckClassContext& context, const std::string& name)
{
    CheckClass& ctxt = context.getOwner();

    if (!(ctxt.symb_was()) && (ctxt.get_fir() < name.length()) && ((name[ctxt.get_fir()] == ' ') || (name[ctxt.get_fir()] == '\t')))
    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.word_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if ((ctxt.get_sec() < name.length()) && name[ctxt.get_sec()] != '\t' && name[ctxt.get_sec()] != ' ' && name[ctxt.get_sec()] != ':')

    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.cg_symb(true);
            ctxt.up_sec();
            ctxt.word_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (!ctxt.is_end_of_class())

    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.cg_end_of_class(true);
            ctxt.word_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (ctxt.is_end_of_class() && (ctxt.is_name_of_class(name.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir())) == 1))

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.cg_symb(false);
            ctxt.add_my_cl(name.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir()));
            ctxt.put_fir(ctxt.get_sec());
            ctxt.class_stage();
            context.setState(CheckClassMap::ClassName);
        }
        catch (...)
        {
            context.setState(CheckClassMap::ClassName);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         CheckClassMap_Default::NameOfClass(context, name);
    }

}

void CheckClassMap_ClassName::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(2);
        ctxt.ch_err();
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_ClassName::DesiredSymb(CheckClassContext& context, const std::string& name)
{
    CheckClass& ctxt = context.getOwner();

    if ((ctxt.get_fir() < name.length()) && (name[ctxt.get_fir()] == ' ' || name[ctxt.get_fir()] == '\t'))
    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.class_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if ((ctxt.get_fir() < name.length()) && name[ctxt.get_fir()] == ':')

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.col_stage();
            context.setState(CheckClassMap::Colon);
        }
        catch (...)
        {
            context.setState(CheckClassMap::Colon);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         CheckClassMap_Default::DesiredSymb(context, name);
    }

}

void CheckClassMap_Colon::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(3);
        ctxt.ch_err();
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_Colon::NextWd(CheckClassContext& context, const std::string& spec)
{
    CheckClass& ctxt = context.getOwner();

    if (!ctxt.symb_was() && (ctxt.get_fir() < spec.length()) && ((spec[ctxt.get_fir()] == ' ') || (spec[ctxt.get_fir()] == '\t')))
    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.col_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if ((ctxt.get_sec() < spec.length()) && spec[ctxt.get_sec()] != '\t' && spec[ctxt.get_sec()] != ' ' && spec[ctxt.get_sec()] != '{')

    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.cg_symb(true);
            ctxt.up_sec();
            ctxt.col_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (ctxt.is_specif(spec.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir())))

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.cg_symb(false);
            ctxt.add_par_cl(spec.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir()));
            ctxt.spec_stage();
            ctxt.put_fir(ctxt.get_sec());
            context.setState(CheckClassMap::Specificator);
        }
        catch (...)
        {
            context.setState(CheckClassMap::Specificator);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (ctxt.is_name_of_class(spec.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir())) == 1)

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.cg_symb(false);
            ctxt.par_stage();
            ctxt.add_par_cl(spec.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir()));
            ctxt.put_fir(ctxt.get_sec());
            context.setState(CheckClassMap::ParentClass);
        }
        catch (...)
        {
            context.setState(CheckClassMap::ParentClass);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         CheckClassMap_Default::NextWd(context, spec);
    }

}

void CheckClassMap_Specificator::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(4);
        ctxt.ch_err();
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_Specificator::NextState(CheckClassContext& context, const std::string& name)
{
    CheckClass& ctxt = context.getOwner();

    if (!(ctxt.symb_was()) && (ctxt.get_fir() < name.length()) && ((name[ctxt.get_fir()] == ' ') || (name[ctxt.get_fir()] == '\t')))
    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.spec_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if ((ctxt.get_sec() < name.length()) && name[ctxt.get_sec()] != '\t' && name[ctxt.get_sec()] != ' ' && name[ctxt.get_sec()] != '{')

    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.cg_symb(true);
            ctxt.up_sec();
            ctxt.spec_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (ctxt.is_name_of_class(name.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir())))

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.add_par_cl(name.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir()));
            ctxt.cg_symb(false);
            ctxt.put_fir(ctxt.get_sec());
            ctxt.par_stage();
            context.setState(CheckClassMap::ParentClass);
        }
        catch (...)
        {
            context.setState(CheckClassMap::ParentClass);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         CheckClassMap_Default::NextState(context, name);
    }

}

void CheckClassMap_ParentClass::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(5);
        ctxt.ch_err();
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_ParentClass::FindBr(CheckClassContext& context, const std::string& str)
{
    CheckClass& ctxt = context.getOwner();

    if ((ctxt.get_fir() < str.length()) && (str[ctxt.get_fir()] == '\t' || str[ctxt.get_fir()] == ' '))
    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.par_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (str[ctxt.get_fir()] == '{')

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.lbr_stage();
            context.setState(CheckClassMap::LeftBracket);
        }
        catch (...)
        {
            context.setState(CheckClassMap::LeftBracket);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         CheckClassMap_Default::FindBr(context, str);
    }

}

void CheckClassMap_LeftBracket::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(6);
        ctxt.ch_err();
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_LeftBracket::FindBr(CheckClassContext& context, const std::string& str)
{
    CheckClass& ctxt = context.getOwner();

    if (!(ctxt.symb_was()) && (ctxt.get_fir() < str.length()) && (str[ctxt.get_fir()] == '}'))
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.rbr_stage();
            context.setState(CheckClassMap::RightBracket);
        }
        catch (...)
        {
            context.setState(CheckClassMap::RightBracket);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (!(ctxt.symb_was()) && (ctxt.get_fir() < str.length()) && (str[ctxt.get_fir()] == '\t' || str[ctxt.get_fir()] == ' '))

    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.up_fir();
            ctxt.up_sec();
            ctxt.lbr_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if ((ctxt.get_sec() < str.length()) && (str[ctxt.get_sec()] != ';'))

    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.cg_symb(true);
            ctxt.up_sec();
            ctxt.lbr_stage();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }
    else if (ctxt.is_func(str.substr(ctxt.get_fir(), ctxt.get_sec() - ctxt.get_fir())))

    {
        CheckClassState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.cg_symb(false);
            ctxt.up_sec();
            ctxt.put_fir(ctxt.get_sec());
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }
    }    else
    {
         CheckClassMap_Default::FindBr(context, str);
    }

}

void CheckClassMap_RightBracket::Default(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(7);
        ctxt.ch_err();
        context.setState(CheckClassMap::ErrOfSymb);
    }
    catch (...)
    {
        context.setState(CheckClassMap::ErrOfSymb);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_RightBracket::FindCol(CheckClassContext& context, const std::string& str)
{
    CheckClass& ctxt = context.getOwner();

    if (str[ctxt.get_fir() + 1] == ';')
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.cr_new_cls();
            context.setState(CheckClassMap::OK);
        }
        catch (...)
        {
            context.setState(CheckClassMap::OK);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
         CheckClassMap_Default::FindCol(context, str);
    }

}

void CheckClassMap_OK::Start(CheckClassContext& context)
{
    CheckClass& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.err_msg(8);
        context.setState(CheckClassMap::StartState);
    }
    catch (...)
    {
        context.setState(CheckClassMap::StartState);
        throw;
    }
    context.getState().Entry(context);

}

void CheckClassMap_ErrOfSymb::Start(CheckClassContext& context)
{

    context.getState().Exit(context);
    context.setState(CheckClassMap::StartState);
    context.getState().Entry(context);

}

//
// Local variables:
//  buffer-read-only: t
// End:
//
